
Helpful in taking union and intersection by repesentation in bitmask

1. RESET the right-most SET bit in a number n

    n = n&(n-1)

2. Counting number of set bits (Brian Kernighan’s algorithm.)

        cnt = 0
        while(n):
            cnt += 1
            n &= (n-1)

3. Checking if given 32 bit integer is power of 2 
 
       * *All the power of 2 have only single bit set e.g. 16 (00010000). 
         *If we minus 1 from this, all the bits from LSB to set bit get toggled,
         *i.e., 16-1 = 15 (00001111). Now if we AND x with (x-1)
         *the result is 0 then we can say that x is power of 2 otherwise not.
         *We have to take extra care when x = 0.

        int isPowerof2(int x) //
        {
            return (x && !(x & x-1));
        }

4. All subsets generation :

    vector<string> seq;  /* stores all non empty subsequences */
    string s;
    cin>>s;
    int n = s.length();
    for(int i=1;i<(1<<n);i++){  // 1 to 2^n-1
        string temp="";
        for(int j=0;j<n;j++){
            if(i&(1<<j)){  // if jth bit in i is set
                temp+=s[j];
            }
        }
        seq.push_back(temp);
    }
    for(int i=0;i<seq.size();i++){
        cout<<seq[i]<<" ";
    }


5. Enumerating all submasks of a given mask :

Given a bitmask m, we want to efficiently iterate through all of its submasks, 
that is, 
  masks s in which only bits that were included in mask m are set.

        for (int s=m; ; s=(s-1)&m) {
            *... you can use s ...*
            if (s==0)  break;
        }

Proof : 

    Suppose we have a current bitmask s, and we want to move on to the next bitmask.
    By subtracting from the mask s one unit, we will remove the rightmost set bit 
    and all bits to the right of it will become 1. 
    Then we remove all the "extra" one bits that are not included in the mask m 
    and therefore can't be a part of a submask. 
    We do this removal by using the bitwise operation (s-1) & m.
    As a result, we "cut" mask s−1 to determine the highest value that it can take, 
    that is, the next submask after s in descending order.       


    Iterating through all masks with their submasks. Complexity O(3^n)
    In many problems, especially those that use bitmask dynamic programming, you want to iterate through all bitmasks and for each mask, iterate through all of its submasks:

        for (int m=0; m<(1<<n); ++m)
            for (int s=m; s; s=(s-1)&m)
                /* ... s and m ... */


!!------------

1. it generate every possible subset of a set , ex:- 1001  :- 0000,0001,1001,1000
  
2. remove last set bit of a number
  n=n&(n-1); // ex:- 101100 -> 101000

 3. get the lowest set bit
 a) i&-i
 b) i&~(i-1)